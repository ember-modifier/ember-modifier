{"version":3,"file":"index.js","sources":["../src/-private/class-based/modifier-manager.ts","../src/-private/class-based/modifier.ts","../src/-private/function-based/modifier-manager.ts","../src/-private/function-based/modifier.ts"],"sourcesContent":["import { capabilities } from '@ember/modifier';\nimport { destroy } from '@ember/destroyable';\nimport type Owner from '@ember/owner';\n\nimport type ClassBasedModifier from './modifier';\nimport type { ArgsFor, ElementFor } from '../signature';\n\n/**\n * The state bucket used throughout the life-cycle of the modifier. Basically a\n * state *machine*, where the framework calls us with the version we hand back\n * to it at each phase. The two states are the two `extends` versions of this\n * below.\n *\n * @internal\n */\ninterface State<S> {\n  instance: ClassBasedModifier<S>;\n}\n\n/**\n * The `State` after calling `createModifier`, and therefore the state available\n * at the start of `InstallModifier`.\n * @internal\n */\ninterface CreatedState<S> extends State<S> {\n  element: null;\n}\n\n/**\n * The `State` after calling `installModifier`, and therefore the state\n * available in all `updateModifier` calls and in `destroyModifier`.\n * @internal\n */\ninterface InstalledState<S> extends State<S> {\n  element: ElementFor<S>;\n}\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement<S>(\n  state: CreatedState<S>,\n  element: ElementFor<S>,\n): InstalledState<S> {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state as State<S> as InstalledState<S>;\n  installedState.element = element;\n  return installedState;\n}\n\nexport default class ClassBasedModifierManager<S> {\n  capabilities = capabilities('3.22');\n\n  constructor(private owner: Owner) {}\n\n  createModifier(\n    modifierClass: typeof ClassBasedModifier,\n    args: ArgsFor<S>,\n  ): CreatedState<S> {\n    const instance = new modifierClass(this.owner, args);\n    return { instance, element: null };\n  }\n\n  installModifier(\n    createdState: CreatedState<S>,\n    element: ElementFor<S>,\n    args: ArgsFor<S>,\n  ): void {\n    const state = installElement(createdState, element);\n    state.instance.modify(element, args.positional, args.named);\n  }\n\n  updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void {\n    state.instance.modify(state.element, args.positional, args.named);\n  }\n\n  destroyModifier({ instance }: InstalledState<S>): void {\n    destroy(instance);\n  }\n}\n","import { setOwner } from '@ember/application';\nimport { setModifierManager } from '@ember/modifier';\nimport type Owner from '@ember/owner';\nimport Manager from './modifier-manager.ts';\nimport type {\n  ElementFor,\n  ArgsFor,\n  DefaultSignature,\n  PositionalArgs,\n  NamedArgs,\n} from '../signature';\nimport type Opaque from '../opaque';\n\n// Preserve the signature on a class-based modifier, so it can be plucked off\n// later (by e.g. Glint), using interface merging with an opaque item to\n// preserve it in the type system. The fact that it's an empty interface is\n// actually the point: it *only* hooks the type parameter into the opaque\n// (nominal) type. Note that this is distinct from the function-based modifier\n// type intentionally, because it is actually the static class side of a\n// class-based modifier which corresponds to the result of calling `modifier()`\n// with a callback defining a function-based modifier.\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport default interface ClassBasedModifier<S = DefaultSignature>\n  extends Opaque<S> {}\n\n/**\n * A base class for modifiers which need more capabilities than function-based\n * modifiers. Useful if, for example:\n *\n * 1. You need to inject services and access them\n * 2. You need fine-grained control of updates, either for performance or\n *    convenience reasons, and don't want to teardown the state of your modifier\n *    every time only to set it up again.\n * 3. You need to store some local state within your modifier.\n *\n * The lifecycle hooks of class modifiers are tracked. When they run, they any\n * values they access will be added to the modifier, and the modifier will\n * update if any of those values change.\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport default class ClassBasedModifier<S = DefaultSignature> {\n  // `args` is passed here for the sake of subclasses to have access to args in\n  // their constructors while having constructors which are properly asssignable\n  // for the superclass.\n  /**\n   *\n   * @param owner An instance of an Owner (for service injection etc.).\n   * @param args The positional and named arguments passed to the modifier.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(owner: Owner, args: ArgsFor<S>) {\n    setOwner(this, owner);\n  }\n\n  /**\n   * Called when the modifier is installed and any time any tracked state used\n   * in the modifier changes.\n   *\n   * If you need to do first-time-only setup, create a class field representing\n   * the initialization state and check it when running the hook. That is also\n   * where and when you should use `registerDestructor` for any teardown you\n   * need to do. For example:\n   *\n   * ```js\n   * function disconnect(instance) {\n   *  instance.observer?.disconnect();\n   * }\n   *\n   * class IntersectionObserver extends Modifier {\n   *   observer;\n   *\n   *   constructor(owner, args) {\n   *     super(owner, args);\n   *     registerDestructor(this, disconnect);\n   *   }\n   *\n   *   modify(element, callback, options) {\n   *     disconnect(this);\n   *\n   *     this.observer = new IntersectionObserver(callback, options);\n   *     this.observer.observe(element);\n   *   }\n   * }\n   * ```\n   *\n   * @param element The element to which the modifier is applied.\n   * @param positional The positional arguments to the modifier.\n   * @param named The named arguments to the modifier.\n   */\n  modify(\n    /* eslint-disable @typescript-eslint/no-unused-vars */\n    element: ElementFor<S>,\n    positional: PositionalArgs<S>,\n    named: NamedArgs<S>,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): void {\n    /* no op, for subclassing */\n  }\n}\n\nsetModifierManager((owner) => new Manager(owner), ClassBasedModifier);\n","import { capabilities } from '@ember/modifier';\nimport type { FunctionBasedModifierDefinition, Teardown } from './modifier';\nimport type { ArgsFor, ElementFor } from '../signature';\n\ninterface State<S> {\n  instance: FunctionBasedModifierDefinition<S>;\n}\n\ninterface CreatedState<S> extends State<S> {\n  element: null;\n}\n\ninterface InstalledState<S> extends State<S> {\n  element: ElementFor<S>;\n  teardown?: Teardown;\n}\n\n// Wraps the unsafe (b/c it mutates, rather than creating new state) code that\n// TS does not yet understand.\nfunction installElement<S>(\n  state: CreatedState<S>,\n  element: ElementFor<S>,\n): InstalledState<S> {\n  // SAFETY: this cast represents how we are actually handling the state machine\n  // transition: from this point forward in the lifecycle of the modifier, it\n  // always behaves as `InstalledState<S>`. It is safe because, and *only*\n  // because, we immediately initialize `element`. (We cannot create a new state\n  // from the old one because the modifier manager API expects mutation of a\n  // single state bucket rather than updating it at hook calls.)\n  const installedState = state as State<S> as InstalledState<S>;\n  installedState.element = element;\n  return installedState;\n}\n\nexport default class FunctionBasedModifierManager<S> {\n  capabilities = capabilities('3.22');\n\n  createModifier(\n    instance: FunctionBasedModifierDefinition<S>,\n  ): CreatedState<S> {\n    return { element: null, instance };\n  }\n\n  installModifier(\n    createdState: CreatedState<S>,\n    element: ElementFor<S>,\n    args: ArgsFor<S>,\n  ): void {\n    const state = installElement(createdState, element);\n\n    const { positional, named } = args;\n    const teardown = createdState.instance(element, positional, named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n\n  updateModifier(state: InstalledState<S>, args: ArgsFor<S>): void {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n\n    const teardown = state.instance(state.element, args.positional, args.named);\n    if (typeof teardown === 'function') {\n      state.teardown = teardown;\n    }\n  }\n\n  destroyModifier(state: InstalledState<S>): void {\n    if (typeof state.teardown === 'function') {\n      state.teardown();\n    }\n  }\n\n  getDebugName(state: InstalledState<S>): string {\n    return state.instance.toString();\n  }\n\n  getDebugInstance(state: InstalledState<S>): InstalledState<S> {\n    return state;\n  }\n}\n","import { setModifierManager } from '@ember/modifier';\nimport type {\n  ElementFor,\n  EmptyObject,\n  NamedArgs,\n  PositionalArgs,\n} from '../signature';\nimport type Modifier from '../class-based/modifier';\nimport FunctionBasedModifierManager from './modifier-manager.ts';\n\n// Provide a singleton manager.\nconst MANAGER = new FunctionBasedModifierManager();\n\n// This type exists to provide a non-user-constructible, non-subclassable\n// type representing the conceptual \"instance type\" of a function modifier.\n// The abstract field of type `never` prevents subclassing in userspace of\n// the value returned from `modifier()`. By extending `Modifier<S>`, any\n// augmentations of the `Modifier` type performed by tools like Glint will\n// also apply to function-based modifiers as well.\nexport declare abstract class FunctionBasedModifierInstance<\n  S,\n> extends Modifier<S> {\n  protected abstract __concrete__: never;\n}\n\n// This provides a type whose only purpose here is to represent the runtime\n// type of a function-based modifier: a virtually opaque item. The fact that it's\n// a bare constructor type allows `modifier()` to preserve type parameters from\n// a generic function it's passed, and by making it abstract and impossible to\n// subclass (see above) we prevent users from attempting to instantiate the return\n// value from a `modifier()` call.\nexport type FunctionBasedModifier<S> =\n  abstract new () => FunctionBasedModifierInstance<S>;\n\n/**\n * The (optional) return type for a modifier which needs to perform some kind of\n * cleanup or teardown -- for example, removing an event listener from an\n * element besides the one passed into the modifier.\n */\nexport type Teardown = () => unknown;\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to write types directly on the callback passed to\n// the `modifier` function and infer the resulting type correctly.\nexport default function modifier<\n  E extends Element,\n  P extends unknown[],\n  N = EmptyObject,\n>(\n  fn: (element: E, positional: P, named: N) => void | Teardown,\n): FunctionBasedModifier<{\n  Args: {\n    Positional: P;\n    Named: N;\n  };\n  Element: E;\n}>;\n\n/**\n * An API for writing simple modifiers.\n *\n * This function runs the first time when the element the modifier was applied\n * to is inserted into the DOM, and it *autotracks* while running. Any values\n * that it accesses will be tracked, including any of its arguments that it\n * accesses, and if any of them changes, the function will run again.\n *\n * **Note:** this will *not* automatically rerun because an argument changes. It\n * will only rerun if it is *using* that argument (the same as with auto-tracked\n * state in general).\n *\n * The modifier can also optionally return a *destructor*. The destructor\n * function will be run just before the next update, and when the element is\n * being removed entirely. It should generally clean up the changes that the\n * modifier made in the first place.\n *\n * @param fn The function which defines the modifier.\n */\n// This overload allows users to provide a `Signature` type explicitly at the\n// modifier definition site, e.g. `modifier<Sig>((el, pos, named) => {...})`.\n// **Note:** this overload must appear second, since TS' inference engine will\n// not correctly infer the type of `S` here from the types on the supplied\n// callback.\nexport default function modifier<S>(\n  fn: (\n    element: ElementFor<S>,\n    positional: PositionalArgs<S>,\n    named: NamedArgs<S>,\n  ) => void | Teardown,\n): FunctionBasedModifier<{\n  Element: ElementFor<S>;\n  Args: {\n    Named: NamedArgs<S>;\n    Positional: PositionalArgs<S>;\n  };\n}>;\n\n// This is the runtime signature; it performs no inference whatsover and just\n// uses the simplest version of the invocation possible since, for the case of\n// setting it on the modifier manager, we don't *need* any of that info, and\n// the two previous overloads capture all invocations from a type perspective.\nexport default function modifier(\n  fn: (\n    element: Element,\n    positional: unknown[],\n    named: object,\n  ) => void | Teardown,\n  options?: {\n    name: string;\n  },\n): FunctionBasedModifier<{\n  Element: Element;\n  Args: {\n    Named: object;\n    Positional: unknown[];\n  };\n}> {\n  fn.toString = () => options?.name || fn.name;\n  // SAFETY: the cast here is a *lie*, but it is a useful one. The actual return\n  // type of `setModifierManager` today is `void`; we pretend it actually\n  // returns an opaque `Modifier` type so that we can provide a result from this\n  // type which is useful to TS-aware tooling (e.g. Glint).\n  return setModifierManager(\n    () => MANAGER,\n    fn,\n  ) as unknown as FunctionBasedModifier<{\n    Element: Element;\n    Args: {\n      Named: object;\n      Positional: unknown[];\n    };\n  }>;\n}\n\n/**\n * @internal\n */\nexport type FunctionBasedModifierDefinition<S> = (\n  element: ElementFor<S>,\n  positional: PositionalArgs<S>,\n  named: NamedArgs<S>,\n) => void | Teardown;\n"],"names":["installElement","state","element","installedState","ClassBasedModifierManager","capabilities","constructor","owner","createModifier","modifierClass","args","instance","installModifier","createdState","modify","positional","named","updateModifier","destroyModifier","destroy","ClassBasedModifier","setOwner","setModifierManager","Manager","FunctionBasedModifierManager","teardown","getDebugName","toString","getDebugInstance","MANAGER","modifier","fn","options","name"],"mappings":"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"}